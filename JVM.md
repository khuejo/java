# JVM

## JVM是什么？
Java语言是一种面向对象的高级语言，它可以在不同的操作系统和硬件平台上运行。但是，由于不同的操作系统和硬件平台具有不同的指令集和内存结构等差异，因此直接将Java源代码编译成本地机器语言是不可行的。为了解决这个问题，Sun公司开发了Java虚拟机（Java Virtual Machine，JVM），它可以将Java源代码编译成通用的中间代码——字节码（ByteCode），再由JVM在不同的操作系统和硬件平台上进行解释和执行，从而来实现“一次编写，到处运行”的特性。除了实现“一次编写，到处运行”之外，JVM还具有其他重要的作用，如：
- 内存管理：JVM负责对Java程序中的对象进行分配、使用和回收，以确保程序能够高效地利用内存资源。
- 安全控制：JVM提供了多层安全机制，包括类加载器、字节码校验器和安全管理器等，以确保Java程序的安全性。
- 多线程支持：JVM可以同时执行多个线程，以实现Java程序的并发性和多任务处理能力。

总之，Java虚拟机是Java程序运行的基础，它通过在不同平台上运行Java字节码来实现“一次编写，到处运行”的特性，同时还具有内存管理、安全控制和多线程支持等功能。

## JVM的组成结构？
Java虚拟机（JVM）的组成部分主要包括以下几个部分：
- 类加载器子系统：类加载器负责将Java字节码文件加载到内存中，并在程序运行时动态地链接和初始化类。类加载器包括启动类加载器、扩展类加载器和应用程序类加载器等。
- 运行时数据区：运行时数据区是指JVM用于存储数据的区域。主要包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。不同的线程拥有独立的虚拟机栈、本地方法栈以及程序计数器，而堆和方法区则是共享的。
- 执行引擎：执行引擎是JVM的核心，负责解释执行Java代码。执行引擎包括解释器和即时编译器（JIT），其中解释器可以直接执行Java字节码，而JIT则将频繁执行的代码编译为本机代码，以提高程序的执行效率。
- 垃圾回收器：垃圾回收器负责对不再使用的对象进行回收和清理，以释放内存空间。JDK中默认提供了多种不同类型的垃圾回收器，如Serial、Parallel、CMS、G1等。
- 本地方法接口（Native Interface）：本地方法接口是JVM与底层操作系统交互的接口。通过本地方法接口，Java程序可以调用本地编写的代码或库，以访问底层资源和执行特定的操作。

总之，JVM是一种用于执行Java程序的虚拟机，主要包括类加载器子系统、运行时数据区、执行引擎、垃圾回收器和本地方法接口等组件。这些组件协同工作，使得Java程序能够在不同的平台上运行，并且具有良好的可移植性和安全性。

## 类加载器子系统是如何执行的？
Java虚拟机（JVM）在运行Java程序时，需要先将程序中的字节码文件加载到内存中。这个过程称为类加载（Class Loading），它主要包括以下三个步骤：

- 加载（Loading）：加载是指查找并加载类的字节码文件。类加载器（ClassLoader）会根据类的全限定名来搜索对应的字节码文件，并将其读入内存中。
- 链接（Linking）：链接是指将类的字节码文件加入到JVM中，以便于执行。链接又分为三个部分：
  - 验证（Verification）：验证是指对类的字节码文件进行验证，以确保其符合Java虚拟机规范和安全规则。
  - 准备（Preparation）：准备是指给类的静态变量分配内存，并赋予默认值。
  - 解析（Resolution）：解析是指将类或接口中的符号引用转换为直接引用。
- 初始化（Initialization）：初始化是指执行类的构造器方法（即&lt;clinit&gt;方法），为类的静态变量赋初值。，为类的静态常量赋初始值。

总之，类加载过程是Java程序运行的基础，它将字节码文件加载到内存中，并进行链接和初始化等操作，最终使得程序能够被执行。类加载器、验证器、准备器、解析器和执行引擎等组成了Java虚拟机的类加载子系统，其中每个组件都发挥着重要的作用。

## 双亲委派机制？
双亲委派是一种类加载器的工作机制，它指的是当一个类加载器需要加载某个类时，它会先将这个请求委托给父类加载器去完成，在父类加载器无法完成该请求时，才会由当前类加载器自己去加载该类。类加载器双亲委派模型的设计理念是基于Java语言的安全性方面的考虑，主要有以下几个原因：
- 避免类的重复加载和冲突：按照双亲委派模型，当一个类加载器需要加载一个类时，它会首先向其父类加载器发送请求，如果父类加载器能够找到并加载该类，那么就直接返回该类的Class对象。这样可以避免相同名称的类被重复加载和冲突。
- 提高类加载的效率：由于Java中大量使用了反射机制，如果不采用双亲委派模型，可能会出现类的混乱、代码注入等安全问题，同时也会带来性能上的损失。
- 加强Java应用程序的安全性：采用双亲委派模型可以确保JVM只会加载受信任的类库，避免了不必要的恶意代码进入系统内部。

总之，类加载器双亲委派模型的设计目的是为了确保Java语言的安全性和可靠性，它通过避免类的重复加载和冲突、提高类加载的效率以及加强Java应用程序的安全性等措施来实现这一目的。尽管双亲委派模型在Java中被广泛使用，但是有些框架和应用程序需要更灵活的类加载机制来加载特定的类或者资源。因此，需要打破双亲委派模型。一些常见的原因包括：
- 加载本地类库：某些应用程序需要使用本地类库，这些类库可能存在于系统目录下或者其他位置，无法通过标准的类路径进行加载。
- 加载动态生成的类：有些框架需要在运行时动态生成代码，这些代码需要通过自定义的类加载器进行加载。
- 加载应用程序特定的配置：应用程序需要读取特定的配置文件，这些文件可能存放在不同的位置，需要使用自定义的类加载器进行加载。

历史上，Java社区中已经有几个著名的项目和框架打破了双亲委派模型，例如，OSGi（Open Services Gateway initiative）是一种用于构建模块化的Java应用程序的规范和框架，它支持在运行时动态添加、删除和更新Java模块。为了支持此类动态模块化的功能，OSGi引入了自定义的类加载器，并打破了双亲委派模型。OSGi中每个模块都有自己的类加载器，因此可以根据需要加载不同版本的相同类库。另一个例子是Tomcat，它是一个Web应用程序容器，支持JSP和Servlet等标准的Java Web技术。为了支持多个Web应用程序之间的隔离和独立性，Tomcat使用了自定义的类加载器，并打破了双亲委派模型。Tomcat中每个Web应用程序都有自己的类加载器，因此可以避免不同Web应用程序之间类的命名冲突。这些框架都采用了自定义的类加载器，并且实现了特定的类加载机制，以便能够更加灵活地加载特定的类或者资源。虽然打破双亲委派模型可以提供更大的灵活性，但也需要特别注意安全问题和类之间的兼容性问题。

## JVM的运行时数据区是什么样的？
Java虚拟机（JVM）运行时数据区是指Java程序在运行时所需的各种数据结构在内存中的表示形式，主要包括以下几个部分：
- 程序计数器（Program Counter Register）：程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的程序计数器。
- Java虚拟机栈（JVM Stack）：每个Java方法被执行时，Java虚拟机会同步地创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的调用都会把新的栈帧压入栈中，方法返回时则将其弹出。
- 本地方法栈（Native Method Stack）：本地方法栈与Java虚拟机栈类似，只是它为Native方法服务。
- Java堆（Java Heap）：Java堆是Java虚拟机管理的最大的一块内存空间，用于存放对象实例和数组。Java堆是所有线程共享的，由于多线程同时进行对象的分配和回收，可能会导致Java堆出现竞争条件，进而出现线程安全问题。为了解决这个问题，JVM采用了各种算法和技术来保证Java堆的线程安全性，包括以下几种方式：
  - 对象分配指针碰撞：将Java堆划分为两部分，一部分已经被使用，另一部分未被使用。当要分配新对象内存时，只需要将指针向未使用部分移动即可，避免了多线程的冲突。
  - 对象分配空闲列表：将Java堆划分为两部分，已使用部分和未使用部分之间用一个指针作为分界点。新创建的对象都位于未使用的部分，当Java虚拟机进行垃圾回收时，将未使用的对象加入到空闲列表中，供下次使用。
  - Thread Local Allocation Buffer（TLAB）：TLAB是一种针对多线程的对象分配优化技术。Java虚拟机为每个线程预先分配一小块内存空间，由该线程独立使用，避免了多线程竞争的问题。
- 方法区（Method Area）：方法区用于存储已经被加载的类的信息，例如类的名称、字段、方法、接口等，也包括字符串常量池等内容。
  - 运行时常量池（Runtime Constant Pool）：运行时常量池是方法区的一部分，它用于存放编译器生成的各种字面量和符号引用，包括类、接口、字段和方法等。
- 直接内存（Direct Memory）：直接内存不是Java虚拟机运行时数据区的一部分，但是它被JVM管理，并且通过Native函数库使用。它可以被看作是一块直接向操作系统申请的内存空间，在需要时可以通过Unsafe类来操作它。

总之，Java虚拟机运行时数据区是Java程序在运行时所需的各种数据结构在内存中的表示形式，主要包括程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区、运行时常量池和直接内存。这些数据区为Java程序的运行提供了必要的支持和环境。

## JVM的垃圾回收器是什么？
JVM的垃圾回收器是负责自动内存管理的组件，用于标记和回收不再使用的对象，并释放它们占据的内存空间。JVM中有多种不同类型的垃圾回收器，每个垃圾回收器都具有不同的优缺点，适合不同的场景和需求。其中，常见的垃圾回收器包括以下几种：
- Serial垃圾回收器：Serial是JVM中最古老的垃圾回收器之一。它是单线程执行的，使用标记-清除算法进行垃圾回收操作。为了避免应用程序停顿时间过长，Serial垃圾回收器会在垃圾回收阶段暂停应用程序，因此仅适用于小型应用程序和测试环境。
- Parallel垃圾回收器：Parallel是一个并行垃圾回收器，可以利用多个CPU核心来加速垃圾回收操作。与Serial垃圾回收器相比，Parallel垃圾回收器的吞吐量更高，但可能会导致较长的停顿时间。它适用于大型应用程序和数据中心等环境。
- CMS（Concurrent Mark Sweep）垃圾回收器：CMS是一个并发垃圾回收器，可以在不暂停应用程序的情况下进行垃圾回收操作。CMS垃圾回收器使用标记-清除算法和多线程并发处理技术，在吞吐量和响应时间之间做了平衡，适用于对停顿时间敏感的应用程序。
- G1（Garbage First）垃圾回收器：G1是一种面向服务端应用程序的垃圾回收器，它采用可预测的停顿时间来实现高效的内存管理。G1垃圾回收器将Java堆分成多个大小相等的区域，每个区域独立进行垃圾回收。它适用于大型、长时间运行的应用程序。

总之，JVM中有多种不同类型的垃圾回收器，每个垃圾回收器都具有不同的优缺点，适合不同的场景和需求。开发人员需要根据应用程序的特点选择合适的垃圾回收器，以便获得最佳的性能和用户体验。

## 垃圾回收器如何识别垃圾？

